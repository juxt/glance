#!/bin/sh
# glance — LLM-optimized output summarizer
# Pipe output in, get a token-efficient summary with head/tail + regex-matched lines
set -e

# --- Configuration ---
GLANCE_CACHE="${XDG_CACHE_HOME:-$HOME/.cache}/glance/captures"
GLANCE_CONFIG="${XDG_CONFIG_HOME:-$HOME/.config}/glance/presets.conf"

# --- Built-in presets ---
# Format: sed-style — first char is delimiter, then name/regex/description
BUILTIN_PRESETS="/errors/error|err|fail|fatal|panic|exception|traceback/Error detection
/warnings/warn|warning|deprecated/Warnings
/status/exit code|status|returned?[[:space:]]+[0-9]+|HTTP[[:space:]]+[45][0-9][0-9]/Status/exit codes"

# --- Helpers ---

plural_lines() { [ "$1" -eq 1 ] && printf '1 line' || printf '%d lines' "$1"; }

# Parse a sed-style preset line: first char is delimiter, then name/regex/desc
# Sets: _prs_name, _prs_regex, _prs_desc
parse_preset_line() {
    _prs_delim=$(printf '%.1s' "$1")
    _prs_rest="${1#?}"
    _prs_name="${_prs_rest%%${_prs_delim}*}"
    _prs_rest="${_prs_rest#*${_prs_delim}}"
    _prs_regex="${_prs_rest%%${_prs_delim}*}"
    _prs_rest="${_prs_rest#*${_prs_delim}}"
    _prs_desc="$_prs_rest"
}

gen_id() {
    # Timestamp + 8-char hex random suffix
    _ts=$(date +%Y%m%d-%H%M%S)
    if [ -r /dev/urandom ]; then
        _rand=$(od -A n -t x1 -N 4 /dev/urandom | tr -d ' \n')
    else
        # shellcheck disable=SC2039
        _rand=$(printf '%04x%04x' "$(( ${RANDOM:-$$} % 65536 ))" "$(( ${RANDOM:-$$} % 65536 ))")
    fi
    printf '%s-%s' "$_ts" "$_rand"
}

ensure_cache_dir() {
    mkdir -p "$GLANCE_CACHE"
}

ensure_config_dir() {
    config_dir="${GLANCE_CONFIG%/*}"
    mkdir -p "$config_dir"
}

get_capture_path() {
    printf '%s/%s.txt' "$GLANCE_CACHE" "$1"
}

# Get built-in preset regex by name. Returns empty if not found.
get_builtin_preset() {
    _name="$1"
    _old_ifs="$IFS"
    IFS='
'
    for _line in $BUILTIN_PRESETS; do
        parse_preset_line "$_line"
        if [ "$_prs_name" = "$_name" ]; then
            printf '%s' "$_prs_regex"
            IFS="$_old_ifs"
            return 0
        fi
    done
    IFS="$_old_ifs"
    return 1
}

# Get user preset regex by name. Returns empty if not found.
get_user_preset() {
    _name="$1"
    [ -f "$GLANCE_CONFIG" ] || return 1
    while IFS= read -r _line || [ -n "$_line" ]; do
        # Skip comments and empty lines
        case "$_line" in '#'*|'') continue ;; esac
        parse_preset_line "$_line"
        if [ "$_prs_name" = "$_name" ]; then
            printf '%s' "$_prs_regex"
            return 0
        fi
    done < "$GLANCE_CONFIG"
    return 1
}

# Resolve preset name to regex (built-in first, then user)
resolve_preset() {
    get_builtin_preset "$1" && return 0
    get_user_preset "$1" && return 0
    printf 'glance: unknown preset: %s\n' "$1" >&2
    return 1
}

# Cross-platform file mtime in epoch seconds
file_mtime() {
    # Try GNU stat first, then macOS stat, then ls fallback
    if stat -c %Y "$1" 2>/dev/null; then
        return 0
    elif stat -f %m "$1" 2>/dev/null; then
        return 0
    else
        # Fallback: no age info
        printf '0'
    fi
}

# Print selected lines from a file in a single pass.
# Args: file linenos_csv filter_pattern [footer_prefix]
# Prints each line whose number is in linenos_csv or that matches filter_pattern.
# If footer_prefix is given, appends a summary line with showing count and sections.
print_matched_lines() {
    _pm_file="$1"
    _pm_linenos="$2"
    _pm_filter="$3"
    _pm_footer="${4:-}"
    _pm_total=$(wc -l < "$_pm_file" | tr -d ' ')
    _pm_width=${#_pm_total}
    [ "$_pm_width" -eq 0 ] && _pm_width=1

    awk -v linenos="$_pm_linenos" -v pattern="$_pm_filter" \
        -v width="$_pm_width" -v footer="$_pm_footer" '
BEGIN { split(linenos, a, ","); for (i in a) show[a[i]] = 1 }
(NR in show) || (pattern != "" && tolower($0) ~ tolower(pattern)) {
    printf "%*d: %s\n", width, NR, $0
    matched[++count] = NR
}
END {
    if (footer == "") exit
    sections = ""; start = 0; prev = 0
    for (i = 1; i <= count; i++) {
        if (start == 0) { start = matched[i]; prev = matched[i]; continue }
        if (matched[i] == prev + 1) { prev = matched[i]; continue }
        seg = (start == prev) ? start : start "-" prev
        sections = (sections == "") ? seg : sections ", " seg
        start = matched[i]; prev = matched[i]
    }
    if (start > 0) {
        seg = (start == prev) ? start : start "-" prev
        sections = (sections == "") ? seg : sections ", " seg
    }
    printf "%s | showing %d | sections: %s ---\n", footer, count, sections
}
' "$_pm_file"
}

# Format seconds ago as human-readable age
format_age() {
    _secs="$1"
    if [ "$_secs" -le 0 ] 2>/dev/null; then
        printf 'unknown'
        return
    fi
    if [ "$_secs" -lt 60 ]; then
        printf '%ds ago' "$_secs"
    elif [ "$_secs" -lt 3600 ]; then
        printf '%dm ago' "$(( _secs / 60 ))"
    elif [ "$_secs" -lt 86400 ]; then
        printf '%dh ago' "$(( _secs / 3600 ))"
    else
        printf '%dd ago' "$(( _secs / 86400 ))"
    fi
}

# --- Pipe mode: read stdin, summarize, store ---

do_pipe() {
    n=10
    filters=""
    no_store=0

    # Parse flags
    while [ $# -gt 0 ]; do
        case "$1" in
            -n|--lines|--head)
                case "$2" in
                    ''|0|*[!0-9]*) printf 'glance: -n must be a positive integer\n' >&2; exit 1 ;;
                esac
                n="$2"; shift 2 ;;
            -f|--filter)
                [ $# -ge 2 ] || { printf 'glance: -f requires a value\n' >&2; exit 1; }
                filters="${filters}${filters:+|}$2"
                shift 2 ;;
            -p|--preset)
                [ $# -ge 2 ] || { printf 'glance: -p requires a value\n' >&2; exit 1; }
                _pregex=$(resolve_preset "$2") || exit 1
                filters="${filters}${filters:+|}${_pregex}"
                shift 2 ;;
            --no-store)
                no_store=1; shift ;;
            *)
                printf 'glance: unknown flag: %s\n' "$1" >&2
                printf 'Try: glance help\n' >&2
                exit 1 ;;
        esac
    done

    # Buffer stdin to temp file
    tmpfile=$(mktemp)
    trap 'rm -f "$tmpfile"' EXIT
    cat > "$tmpfile"

    total=$(awk 'END { print NR }' "$tmpfile")

    # Store capture (unless --no-store)
    capture_id=""
    if [ "$no_store" -eq 0 ]; then
        ensure_cache_dir
        capture_id=$(gen_id)
        capture_path=$(get_capture_path "$capture_id")
        cp "$tmpfile" "$capture_path"
    fi

    # --- Build output lines ---
    # Collect line numbers to display (1-indexed)
    # Start with head and tail
    if [ "$total" -eq 0 ]; then
        # Empty input
        if [ -n "$capture_id" ]; then
            printf '%s\n' "--- glance id=${capture_id} | 0 lines | showing 0 ---"
        else
            printf '%s\n' "--- glance | 0 lines | showing 0 ---"
        fi
        return
    fi

    # Calculate head/tail ranges
    if [ "$total" -le "$(( n * 2 ))" ]; then
        head_end="$total"
        tail_start="$(( total + 1 ))"
    else
        head_end="$n"
        tail_start="$(( total - n + 1 ))"
    fi

    # Build line numbers CSV
    _linenos=""
    _i=1
    while [ "$_i" -le "$head_end" ]; do
        _linenos="${_linenos}${_linenos:+,}${_i}"
        _i=$(( _i + 1 ))
    done
    if [ "$tail_start" -le "$total" ]; then
        _i="$tail_start"
        while [ "$_i" -le "$total" ]; do
            _linenos="${_linenos}${_linenos:+,}${_i}"
            _i=$(( _i + 1 ))
        done
    fi

    # Build footer prefix
    if [ -n "$capture_id" ]; then
        _footer="--- glance id=${capture_id} | $(plural_lines "$total")"
    else
        _footer="--- glance | $(plural_lines "$total")"
    fi

    print_matched_lines "$tmpfile" "$_linenos" "$filters" "$_footer"
}

# --- Show subcommand ---

do_show() {
    if [ $# -lt 1 ]; then
        printf 'Usage: glance show <id> [--lines N-M] [--filter regex] [--around N C]\n' >&2
        exit 1
    fi

    _id="$1"; shift

    # Validate capture ID: reject slashes, dots-only, and path traversal
    case "$_id" in
        */* | *..* | '') printf 'glance: invalid capture ID: %s\n' "$_id" >&2; exit 1 ;;
    esac

    _path=$(get_capture_path "$_id")

    if [ ! -f "$_path" ]; then
        printf 'glance: capture not found: %s\n' "$_id" >&2
        printf 'Use "glance list" to see stored captures.\n' >&2
        exit 1
    fi

    # No extra flags → dump full output
    if [ $# -eq 0 ]; then
        cat "$_path"
        return
    fi

    _total=$(wc -l < "$_path" | tr -d ' ')
    _linenos=""
    _show_filters=""

    # Parse show flags — collect line numbers and filters
    while [ $# -gt 0 ]; do
        case "$1" in
            -l|--lines)
                _range="$2"; shift 2
                _start="${_range%-*}"
                _end="${_range#*-}"
                case "$_start" in ''|*[!0-9]*) printf 'glance show: invalid range, must be N-M\n' >&2; exit 1 ;; esac
                case "$_end" in ''|*[!0-9]*) printf 'glance show: invalid range, must be N-M\n' >&2; exit 1 ;; esac
                [ "$_end" -gt "$_total" ] && _end="$_total"
                _i="$_start"
                while [ "$_i" -le "$_end" ]; do
                    _linenos="${_linenos}${_linenos:+,}${_i}"
                    _i=$(( _i + 1 ))
                done ;;
            -f|--filter)
                _show_filters="${_show_filters}${_show_filters:+|}$2"
                shift 2 ;;
            -p|--preset)
                _pregex=$(resolve_preset "$2") || exit 1
                _show_filters="${_show_filters}${_show_filters:+|}${_pregex}"
                shift 2 ;;
            -a|--around)
                _center="$2"
                _ctx="${3:-5}"
                case "$_center" in ''|0|*[!0-9]*) printf 'glance show: --around center must be a positive integer\n' >&2; exit 1 ;; esac
                case "$_ctx" in ''|0|*[!0-9]*) printf 'glance show: --around context must be a positive integer\n' >&2; exit 1 ;; esac
                shift; shift
                [ $# -gt 0 ] && shift
                _from=$(( _center - _ctx ))
                [ "$_from" -lt 1 ] && _from=1
                _to=$(( _center + _ctx ))
                [ "$_to" -gt "$_total" ] && _to="$_total"
                _i="$_from"
                while [ "$_i" -le "$_to" ]; do
                    _linenos="${_linenos}${_linenos:+,}${_i}"
                    _i=$(( _i + 1 ))
                done ;;
            *)
                printf 'glance show: unknown flag: %s\n' "$1" >&2
                exit 1 ;;
        esac
    done

    _footer="--- glance show ${_id} | $(plural_lines "$_total")"
    print_matched_lines "$_path" "$_linenos" "$_show_filters" "$_footer"
}

# --- List subcommand ---

do_list() {
    ensure_cache_dir
    _found=0
    _now=$(date +%s)
    for _f in "$GLANCE_CACHE"/*.txt; do
        [ -f "$_f" ] || continue
        _found=1
        _id="${_f##*/}"
        _id="${_id%.txt}"
        _lines=$(wc -l < "$_f" | tr -d ' ')
        _mtime=$(file_mtime "$_f")
        if [ "$_mtime" -gt 0 ] 2>/dev/null; then
            _age=$(( _now - _mtime ))
            _age_str=$(format_age "$_age")
        else
            _age_str="unknown"
        fi
        printf '%s\t%d lines\t%s\n' "$_id" "$_lines" "$_age_str"
    done
    if [ "$_found" -eq 0 ]; then
        printf 'No stored captures.\n'
    fi
}

# --- Clean subcommand ---

do_clean() {
    if [ "$1" = "--all" ]; then
        rm -rf "$GLANCE_CACHE"
        [ -f "$GLANCE_CONFIG" ] && rm -f "$GLANCE_CONFIG"
        printf 'Purged all captures and user presets.\n'
    else
        rm -rf "$GLANCE_CACHE"
        printf 'Purged all captures.\n'
    fi
}

# --- Presets subcommands ---

do_presets() {
    if [ $# -eq 0 ]; then
        printf 'Usage: glance presets <list|add|remove>\n' >&2
        exit 1
    fi

    _sub="$1"; shift
    case "$_sub" in
        list)
            printf 'Built-in presets:\n'
            _old_ifs="$IFS"
            IFS='
'
            for _line in $BUILTIN_PRESETS; do
                parse_preset_line "$_line"
                printf '  %-10s  %-50s  %s\n' "$_prs_name" "$_prs_regex" "$_prs_desc"
            done
            IFS="$_old_ifs"

            if [ -f "$GLANCE_CONFIG" ]; then
                printf '\nUser presets:\n'
                while IFS= read -r _line || [ -n "$_line" ]; do
                    case "$_line" in '#'*|'') continue ;; esac
                    parse_preset_line "$_line"
                    printf '  %-10s  %-50s  %s\n' "$_prs_name" "$_prs_regex" "$_prs_desc"
                done < "$GLANCE_CONFIG"
            fi
            ;;
        add)
            # Parse optional -d flag
            _delim=""
            if [ $# -ge 2 ] && [ "$1" = "-d" ]; then
                _delim="$2"; shift 2
            fi
            if [ $# -lt 2 ]; then
                printf 'Usage: glance presets add [-d delim] <name> <regex> [description]\n' >&2
                exit 1
            fi
            _name="$1"
            _regex="$2"
            _desc="${3:-}"

            # Validate preset name: alphanumeric, hyphens, underscores; must start with letter/digit
            case "$_name" in
                ''|-*|*[!a-zA-Z0-9_-]*)
                    printf 'glance: invalid preset name: %s (must start with alphanumeric, use only alphanumeric/hyphens/underscores)\n' "$_name" >&2
                    exit 1 ;;
            esac

            # Check not a built-in name
            if get_builtin_preset "$_name" >/dev/null 2>&1; then
                printf 'glance: cannot override built-in preset: %s\n' "$_name" >&2
                exit 1
            fi

            # Pick delimiter: use -d if given, otherwise auto-pick
            if [ -n "$_delim" ]; then
                case "$_regex" in
                    *"$_delim"*)
                        printf 'glance: delimiter %s appears in regex, choose another\n' "$_delim" >&2
                        exit 1 ;;
                esac
            fi
            if [ -z "$_delim" ]; then
                _delim=""
                for _c in / , @ '#' '%' '~' '!'; do
                    case "$_regex" in
                        *"$_c"*) continue ;;
                        *) _delim="$_c"; break ;;
                    esac
                done
                if [ -z "$_delim" ]; then
                    printf 'glance: regex contains all candidate delimiters, use -d to specify one\n' >&2
                    exit 1
                fi
            fi

            ensure_config_dir
            # Remove existing entry with same name, then append
            if [ -f "$GLANCE_CONFIG" ]; then
                _tmp=$(mktemp)
                while IFS= read -r _line || [ -n "$_line" ]; do
                    case "$_line" in '#'*|'') printf '%s\n' "$_line" >> "$_tmp"; continue ;; esac
                    parse_preset_line "$_line"
                    [ "$_prs_name" = "$_name" ] && continue
                    printf '%s\n' "$_line" >> "$_tmp"
                done < "$GLANCE_CONFIG"
                mv "$_tmp" "$GLANCE_CONFIG"
            fi
            printf '%s%s%s%s%s%s\n' "$_delim" "$_name" "$_delim" "$_regex" "$_delim" "$_desc" >> "$GLANCE_CONFIG"
            printf 'Added preset: %s\n' "$_name"
            ;;
        remove)
            if [ $# -lt 1 ]; then
                printf 'Usage: glance presets remove <name>\n' >&2
                exit 1
            fi
            _name="$1"

            # Can't remove built-ins
            if get_builtin_preset "$_name" >/dev/null 2>&1; then
                printf 'glance: cannot remove built-in preset: %s\n' "$_name" >&2
                exit 1
            fi

            if [ ! -f "$GLANCE_CONFIG" ]; then
                printf 'glance: preset not found: %s\n' "$_name" >&2
                exit 1
            fi

            _found=0
            _tmp=$(mktemp)
            while IFS= read -r _line || [ -n "$_line" ]; do
                case "$_line" in '#'*|'') printf '%s\n' "$_line" >> "$_tmp"; continue ;; esac
                parse_preset_line "$_line"
                if [ "$_prs_name" = "$_name" ]; then
                    _found=1
                    continue
                fi
                printf '%s\n' "$_line" >> "$_tmp"
            done < "$GLANCE_CONFIG"
            mv "$_tmp" "$GLANCE_CONFIG"

            if [ "$_found" -eq 1 ]; then
                printf 'Removed preset: %s\n' "$_name"
            else
                printf 'glance: preset not found: %s\n' "$_name" >&2
                exit 1
            fi
            ;;
        *)
            printf 'glance presets: unknown subcommand: %s\n' "$_sub" >&2
            exit 1 ;;
    esac
}

# --- Help subcommand ---

do_help() {
    if [ $# -gt 0 ]; then
        case "$1" in
            show)
                cat <<'HELPEOF'
glance show — retrieve stored capture output

Usage:
  glance show <id>                    Full stored output
  glance show <id> -l 50-80           Lines 50 through 80
  glance show <id> -f regex           Filter within stored output
  glance show <id> -p errors          Filter with preset
  glance show <id> -a 247 5           5 lines context around line 247

Flags:
  -l, --lines N-M      Line range
  -f, --filter REGEX   Filter pattern (repeatable, OR)
  -p, --preset NAME    Preset filter (repeatable, OR)
  -a, --around N [C]   Context around line N (default C=5)

The <id> is the full ID shown in the glance footer when piping output.
Exact match required — use "glance list" to see all stored captures.
HELPEOF
                return ;;
            list)
                cat <<'HELPEOF'
glance list — show stored captures

Usage:
  glance list

Displays each capture's ID, line count, and age.
HELPEOF
                return ;;
            clean)
                cat <<'HELPEOF'
glance clean — purge stored captures

Usage:
  glance clean          Remove all stored captures
  glance clean --all    Also remove user presets
HELPEOF
                return ;;
            presets)
                cat <<'HELPEOF'
glance presets — manage filter presets

Usage:
  glance presets list                              Show all presets
  glance presets add [-d delim] <name> <re> [desc] Add user preset
  glance presets remove <name>                     Remove user preset

Config format (sed-style): first char is the delimiter, then name/regex/desc:
  /mypreset/error|fail/My description

The delimiter is auto-picked (first of / , @ # % ~ ! not in the regex).
Use -d to override: glance presets add -d ',' mypreset 'a/b' 'desc'

Built-in presets cannot be removed or overridden.
HELPEOF
                printf 'User presets are stored in %s\n' "$GLANCE_CONFIG"
                return ;;
        esac
    fi

    cat <<'HELPEOF'
glance — LLM-optimized output summarizer

Pipe command output in, get a token-efficient summary showing head/tail
lines plus regex-matched lines, with an ID to drill into full output.

PIPE MODE:
  command | glance                  Head 10 + tail 10
  command | glance -n 5             Head 5 + tail 5
  command | glance -f 'ERROR|WARN'  + regex filter matches
  command | glance -p errors        + preset filter
  command | glance --no-store       Don't store, no ID

PIPE FLAGS:
  -n, --head N       Head/tail line count (default: 10)
  -f, --filter REGEX Additional middle-line filter (repeatable, OR)
  -p, --preset NAME  Named preset filter (repeatable, OR)
  --no-store         Don't store capture, no ID issued

All filter matching is case-insensitive.

SUBCOMMANDS:
  glance help [cmd]                    This help (or help for cmd)
  glance show <id>                     Full stored output
  glance show <id> -l 50-80            Line range
  glance show <id> -f 'regex'          Filter stored output
  glance show <id> -p errors           Filter with preset
  glance show <id> -a 247 5            Context around line
  glance list                          List stored captures
  glance clean                         Purge captures
  glance presets list                  Show all presets
  glance presets add [-d D] <n> <re> [desc]  Add user preset
  glance presets remove <name>         Remove user preset

BUILT-IN PRESETS:
HELPEOF
    _old_ifs="$IFS"
    IFS='
'
    for _line in $BUILTIN_PRESETS; do
        parse_preset_line "$_line"
        printf '  %-10s %s\n' "$_prs_name" "$_prs_regex"
    done
    IFS="$_old_ifs"
    cat <<'HELPEOF'

EXAMPLES:
  # Quick look at build output
  make 2>&1 | glance

  # Find errors in a long log
  kubectl logs pod/api | glance -p errors

  # Combine presets and custom filter
  docker compose up 2>&1 | glance -p errors -p status -f 'db:5432'

  # Drill into a specific capture (use full ID from footer)
  glance show 20260219-143022-a3f8b1c0 -a 247 5

PATHS:
HELPEOF
    printf '  captures:  %s\n' "$GLANCE_CACHE"
    printf '  presets:   %s\n' "$GLANCE_CONFIG"
}

# --- Main dispatch ---

# Check if stdin is a pipe (for pipe mode detection)
if [ $# -eq 0 ] && [ -t 0 ]; then
    printf 'glance: no input. Pipe command output to glance or use a subcommand.\n' >&2
    printf 'Try: glance help\n' >&2
    exit 1
fi

case "${1:-}" in
    help)
        shift; do_help "$@" ;;
    show)
        shift; do_show "$@" ;;
    list)
        do_list ;;
    clean)
        shift; do_clean "$@" ;;
    presets)
        shift; do_presets "$@" ;;
    "")
        # Pipe mode with no arguments
        do_pipe ;;
    -*)
        # Pipe mode with flags
        do_pipe "$@" ;;
    *)
        printf 'glance: unknown command: %s\n' "$1" >&2
        printf 'Try: glance help\n' >&2
        exit 1 ;;
esac
